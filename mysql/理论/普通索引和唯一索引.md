#### 普通索引和唯一索引在查询上的区别
执行查询的语句是 `select id from T where k=5`。这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，可以认为数据页内部通过二分法来定位记录.
区别如下
1. 对于普通索引来说，会查找满足当前 k=5 的第一条记录，然后继续查找，直到碰到第一个不满足 k=5 的记录为止。
2. 唯一索引，会查找到当前满足k=5 的记录就停止了。因为唯一索引是唯一的。

#### 更新的不同
在说普通索引和唯一索引在更新上的不同时，首先的需要说一下 `change buffer` , 那什么是 `change buffer` 了?

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

实际上它是`可以持久化的数据`。也就是说，change buffer 在`内存中有拷贝`，`也会被写入到磁盘上`

`change buffer` 用的是 `buffer pool` 里的`内存`，因此不能无限增大。change buffer 的大小，可以通过参数 `innodb_change_buffer_max_size` 来动态设置。这个参数设置为 `50` 的时候，表示 `change buffer` 的大小最多只能占用 `buffer pool` 的 `50%`。

如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的

第一种情况是，这个`记录要更新的目标页在内存中`。这时，InnoDB 的处理流程如下：

* 对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；
* 对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。

这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。

第二种情况是，这个`记录要更新的目标页不在内存中`。这时，InnoDB 的处理流程如下：
* 对于唯一索引来说，`需要将数据页读入内存`，判断到没有冲突，插入这个值，语句执行结束；
* 对于普通索引来说，则是将更新记录在 `change buffer`，语句执行就结束了。

将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。`change buffer 因为减少了随机磁盘访问`，所以对更新性能的提升是会很明显的.

`change buffer 只限于用在普通索引的场景下，而不适用于唯一索引`.
对于`唯一索引`来说，所有的更新操作都要`先判断这个操作是否违反唯一性约束`。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将`数据页`读入`内存`才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了



