### 隔离性与隔离级别
提起事务就会谈到事务的几个特点，ACID
* 原子性（Atomicity）
* 一致性（Consistency）
* 隔离性（Isolation）
* 持久性（Durability）
这里主要说一下 `隔离性`.

* 为啥需要隔离性了？
我们想象这样一个场景，程序员和程序媛分别往数据库提交了事务，当数据库有多个事务同时执行的时候，就可能出现 `脏读`, `不可重复读`，`幻读`的问题。为了解决这些问题，才有了 `隔离级别` 的概念。

隔离级别包括
* 读未提交（read uncommitted）: 一个事务还没提交，他所做的变更就可以被别的事务看到。
* 读提交（read committed）: 一个事务提交了，他所做的变更才能被其他事务看到。
* 可重复读（repeatable committed）: 一个事务在执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
* 串行化（serializeble）: 对于同一行记录，`写` 会加 `写锁`，`读` 会加 `读锁`。当读写锁冲突时，后访问的事务必须等待前一个事务完成才可以继续

下面是一个列子，我们通过这个例子来看看几种隔离级别对结果的影响。现在我有一个表 tbl_user, 其中一行的值为 1。
 ```sql
 create table tbl_user(id int) engine=InnoDB;
 insert into tbl_user(id) values(1);
 ```

|  事务A   |   事务B   |
| --- | --- |
| 启动事务查询得到值 1 | 启动事务 |
|   | 查询得到值1 |
|   | 将1改成2 |
| 查询得到值v1  | |
|   | 提交事务B | 
| 查询得到值V2| | 
| 提交事务A  | |
|  查询得到V3 |   |

来看看在不同隔离级别下，事务 A 会有那些不同的返回结果，也就是表格中 V1，V2，V3 的返回值有什么不同。
* 如果隔离级别是 "读未提交"，则 V1 的值就是 2，这个时候事务 B 虽然还没提交，但是结果已经被 A 看到了。所以 V2，V3 都是 2.

* 如果隔离级别是 “读提交”, 则 V1 的值是 1, V2, V3的值是 2. 事务 B 在的更新在提交事务后才可以被 A 看到。

* 如果隔离级别是 “可重复读”，则 V1，V2 的值是 1，V3 的值是 2。之所以 V2 的值是 1，遵循的就是要求：事务在执行期间看到的前后必须是一致的。

* 如果隔离级别是 “串行化”，则在事务 B 执行 “讲 1 改成 2 ”的时候，会被锁住，知道事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看，V1，V2 值是 1，V3 的值是 2

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。
> 在“可重复读”隔离级别下，这个视图是在`事务启动`时创建的。整个事务存在期间都用这个视图。

> 在“读提交”隔离级别下，这个视图是在每个 sql 语句开始执行的时候创建的。

> 在“读未提交”隔离级别下，直接返回记录上最新的值，没有视图概念

> 而”串行化“隔离级别下直接用枷锁的方式来避免并行访问

我们可以看到在不同隔离级别下，数据库的行为是不同的。Oracle 数据库的默认隔离级别其实是 “读提交”.

你可以使用 `select @@transaction_isolation` 或者 `show variables "transaction_isolation"` 查看当前数据库的隔离级别

```
mysql> select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
```

如果想改变可以在启动配置文件 `my.cnf`，中配置改变

```
[mysqld]
transaction-isolation = SERIALIZABLE
```

总共四个值：`REPEATABLE READ` | `READ COMMITTED` | `READ UNCOMMITTED` | `SERIALIZABLE`

设置好，重启就可以看到

```
mysql> select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| SERIALIZABLE            |
+-------------------------+
```

#### 为什么建议不要使用长事务
1. 长事务就意味着系统里面会存在很多老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面他可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。
2. 长事务还会占用锁资源，可能拖垮整个库。

#### 事务的启动方式
1. 显示启动事务语句。`begin` 或 `start transaction`。配套提交语句是 `commit` ,回滚是 `rollback`。

2. `set autocommit=0`, 这个命令会将这个线程的自动提交关掉。以为这你执行这个 `select` 语句，这个事务就启动了。而且不会自动提交。这个事务持续存在知道你主动执行 `commit` 或 `rollback` 语句，或者断开连接。

建议设置为 `set autocommit=0`, 显示启动事务。

你可以使在 `information_schema` 库 `innodb_trx` 表中查询长事务，比如下面的语句是查询持续时间超过 60s 的事务
```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
``` 

