### 隔离性与隔离级别
提起事务就会谈到事务的几个特点，ACID
* 原子性（Atomicity）
* 一致性（Consistency）
* 隔离性（Isolation）
* 持久性（Durability）
这里主要说一下 `隔离性`.

* 为啥需要隔离性了？
我们想象这样一个场景，程序员和程序媛分别往数据库提交了事务，当数据库有多个事务同时执行的时候，就可能出现 `脏读`, `不可重复读`，`幻读`的问题。为了解决这些问题，才有了 `隔离级别` 的概念。

隔离级别包括
* 读未提交（read uncommitted）: 一个事务还没提交，他所做的变更就可以被别的事务看到。
* 读提交（read committed）: 一个事务提交了，他所做的变更才能被其他事务看到。
* 可重复读（repeatable committed）: 一个事务在执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
* 串行化（serializeble）: 对于同一行记录，`写` 会加 `写锁`，`读` 会加 `读锁`。当读写锁冲突时，后访问的事务必须等待前一个事务完成才可以继续

下面是一个列子，我们通过这个例子来看看几种隔离级别对结果的影响。现在我有一个表 tbl_user, 其中一行的值为 1。
 ```sql
 create table tbl_user(id int) engine=InnoDB;
 insert into tbl_user(id) values(1);
 ```

|  事务A   |   事务B   |
| --- | --- |
| 启动事务查询得到值 1 | 启动事务 |
|   | 查询得到值1 |
|   | 将1改成2 |
| 查询得到值v1  | |
|   | 提交事务B | 
| 查询得到值V2| | 
| 提交事务A  | |
|  查询得到V3 |   |