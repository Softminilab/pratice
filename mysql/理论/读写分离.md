#### 读写分离
* 的主要目标就是`分摊主库的压力`

#### 读写分离基本架构
![读写分离基本架构]](https://github.com/kareTauren/pratice/blob/master/mysql/%E7%90%86%E8%AE%BA/img/RW.png)

客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由`客户端来选择后端数据库进行查询`。

#### 读写分离 proxy 架构
![读写分离proxy基本架构]](https://github.com/kareTauren/pratice/blob/master/mysql/%E7%90%86%E8%AE%BA/img/RWProxy.jpg)

在 MySQL 和客户端之间有一个`中间代理层 proxy`，客户端`只连接 proxy`， 由 proxy 根据请求类型和上下文决定请求的`分发路由`

##### 客户端直连和带 proxy 的读写分离架构,各自的特点
1. `客户端直连方案`，因为`少了一层 proxy 转发`，所以`查询性能稍微好一点儿`，并且`整体架构简单`，`排查问题更方便`。但是这种方案，`由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息`。你可能会觉得这样客户端也太麻烦了，`信息大量冗余`，`架构很丑`。其实也未必，一般采用这样的架构，一定会伴随一个`负责管理后端的组件`，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发

2. 带 proxy 的架构，对`客户端比较友好`。客户端`不需要关注后端细节`，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有`高可用架构`。因此，带 proxy 架构的整体就相对比较复杂。

---------------------

但是不管以上任何一种架构，都会遇到过期读的问题，
`由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。`

##### 过期读的概念
“在从库上会读到系统的一个过期状态”的现象，暂且称之为“过期读

处理过期读的方案
1. 强制走主库方案；
2. sleep 方案；
3. 判断主备无延迟方案；
4. 配合 semi-sync 方案；
5. 等主库位点方案；
6. 等 GTID 方案

###### 强制走主库方案
强制走主库方案其实就是，将`查询请求做分类`
1. 对于必须要拿到最新结果的请求，强制将其发到主库上,比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库
2. 对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库

###### Sleep 方案
`主库更新后`，读`从库之前先 sleep 一下`。具体的方案就是，类似于执行一条 `select sleep(1) `命令
但是此方法会存在不精确的问题。
1. 如果这个查询请求本来 0.5 秒就可以在从库上拿到正确结果，也会等 1 秒；
2. 如果延迟超过 1 秒，还是会出现过期读。

###### 判断主备无延迟方案
要确保备库无延迟，通常有三种做法。
1. 第一种确保主备无延迟的方法是，每次从库执行查询请求前，先判断 `seconds_behind_master` 是否已经等于 `0`。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求.
> `show slave status` 结果里的 `seconds_behind_master` 参数的值，可以用来`衡量主备延迟时间的长短`

![show slave status 结果]](https://github.com/kareTauren/pratice/blob/master/mysql/%E7%90%86%E8%AE%BA/img/slave_status.png)


2. 第二种方法，对比位点确保主备无延迟
* Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；
* Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。

如果 `Master_Log_File` 和 `Relay_Master_Log_File`、`Read_Master_Log_Pos` 和 `Exec_Master_Log_Pos` 这`两组值完全相同`，就表示接收到的`日志已经同步完成`

3. 第三种方法，对比 GTID 集合确保主备无延迟
* Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。
* Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；
* Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。

如果这两个`集合相同`，也表示备库接收到的日志都已经同步完成

###### 配合 semi-sync
要解决这个问题，就要引入`半同步复制`，也就是 `semi-sync replication`。
semi-sync 做了这样的设计：
1. 事务提交的时候，主库把 binlog 发给从库。
2. 从库收到 binlog 以后，发回给主库一个 ack 表示收到
3. 主库收到 ack 以后，才能给客户端返回“事务完成”确认

也就是说，如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志

###### 等主库位点方案
```sql
select master_pos_wait(file, pos[, timeout]);
```
这条命令的逻辑如下：
1. 它是在从库执行的；
2. 参数 file 和 pos 指的是主库上的文件名和位置；
3. timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。

这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。

当然，除了正常返回一个正整数 M 外，这条命令还会返回一些其他结果，包括：
1. 如果执行期间，备库同步线程发生异常，则返回 NULL；
2. 如果等待超过 N 秒，就返回 -1；
3. 如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。

执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：
1. trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的 File 和 Position；
2. 选定一个从库执行查询语句；
3. 在从库上执行 select master_pos_wait(File, Position, 1)；
4. 如果返回值是 >=0 的正整数，则在这个从库执行查询语句；
5. 否则，到主库执行查询语句

`主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查`

###### GTID 方案
```sql
 select wait_for_executed_gtid_set(gtid_set, 1);
 ```
 这条命令的逻辑是：
 1. 等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；
 2. 超时返回 1。

 而 MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询

 这时，等 GTID 的执行流程就变成了：
 1. trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；
 2. 选定一个从库执行查询语句；
 3. 在从库上执行 `select wait_for_executed_gtid_set(gtid1, 1)`；
 4. 如果返回值是 0，则在这个从库执行查询语句；
 5. 否则，到主库执行查询语句

* 如何让 mysql 执行完事务后，返回包带上 GTID?
你只需要将参数 `session_track_gtids` 设置为 `OWN_GTID`，然后通过 `API 接口 ``mysql_session_track_get_first` 从返回包解析出 GTID 的值即可`


